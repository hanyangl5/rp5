
#pragma kernel SSSSS
#pragma kernel Composite
#pragma require WaveBallot

#include "HLSLSupport.cginc"
#include "include/material.hlsl"
#include "include/common.hlsl"
#include "include/debug.hlsl"
Texture2D<float> depth_tex;
Texture2D<float4> material_id_tex;
Texture2D<float4> color_tex;
RWTexture2D<float4> sss_tex;

SamplerState my_linear_clamp_sampler;
SamplerState my_point_clamp_sampler;

float correction;
float2 step;
uint width;
uint height;

float4 Blur(float2 uv) {
    // Gaussian weights for the six samples around the current pixel:
    //   -3 -2 -1 +1 +2 +3
    float w[6] = { 0.006,   0.061,   0.242,  0.242,  0.061, 0.006 };
    float o[6] = {  -1.0, -0.6667, -0.3333, 0.3333, 0.6667,   1.0 };

    // Fetch color and linear depth for current pixel:
    float4 colorM = color_tex.SampleLevel(my_point_clamp_sampler, uv, 0);
    float depthM = depth_tex.SampleLevel(my_point_clamp_sampler, uv, 0);

    // Accumulate center sample, multiplying it with its gaussian weight:
    float4 colorBlurred = colorM;
    colorBlurred.rgb *= 0.382;

    // Calculate the step that we will use to fetch the surrounding pixels,
    // where "step" is:
    //     step = sssStrength * gaussianWidth * pixelSize * dir
    // The closer the pixel, the stronger the effect needs to be, hence
    // the factor 1.0 / depthM.
    float2 finalStep = colorM.a * step / depthM;

    // Accumulate the other samples:
    [unroll]
    for (int i = 0; i < 6; i++) {
        // Fetch color and depth for current sample:
        float2 offset = uv + o[i] * finalStep;
        float3 color = color_tex.SampleLevel(my_linear_clamp_sampler, offset, 0).rgb;
        float depth = depth_tex.SampleLevel(my_point_clamp_sampler, offset, 0);

        // If the difference in depth is huge, we lerp color back to "colorM":
        float s = min(0.0125 * correction * abs(depthM - depth), 1.0);
        color = lerp(color, colorM.rgb, s);

        // Accumulate:
        colorBlurred.rgb += w[i] * color;
    }

    // The result will be alpha blended with current buffer by using specific 
    // RGB weights. For more details, I refer you to the GPU Pro chapter :)
    return colorBlurred;
}

[numthreads(FULL_SCREEN_CS_THREAD_X, FULL_SCREEN_CS_THREAD_Y, FULL_SCREEN_CS_THREAD_Z)] 
void SSSSS(uint3 id : SV_DispatchThreadID)
{   
    if (asuint(material_id_tex.Load(id).w) == MATERIAL_ID_SKIN) {
        float4 result = color_tex[id.xy];
        float2 uv = (id.xy + 0.5) / float2(width, height);
        sss_tex[id.xy] = Blur(uv);
    }
}

Texture2D<float4> src_tex;
RWTexture2D<float4> dst_tex;

[numthreads(FULL_SCREEN_CS_THREAD_X, FULL_SCREEN_CS_THREAD_Y, FULL_SCREEN_CS_THREAD_Z)] 
void Composite(uint3 id : SV_DispatchThreadID)
{   
    float4 result = dst_tex.Load(id);
    result.xyz = src_tex.Load(id).xyz;
    dst_tex[id.xy] = result;
}