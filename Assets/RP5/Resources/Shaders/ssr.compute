/*
Screen Space Reflection 

1. screen space marching instead of 3d space marching
2. reduce divergence using rasterization

*/
#include  "include/common.hlsl"
#include  "include/transform.hlsl"

#pragma kernel SSR_CS
#pragma require WaveBallot

Texture2D<float4> depth_stencil_tex;
Texture2D<float4> color_tex;
Texture2D<float4> normal_tex; // world normal
RWTexture2D<float4> ssr_tex;
float4x4 inverse_view_projection;
float4x4 view_projection;
float3 world_space_camera_pos;
SamplerState my_linear_clamp_sampler;
int width;
int height;
float camera_near_plane;

float SSR_MAX_RAY_DISTANCE = 70;
float SSR_DEPTH_THICKNESS = 1.0;
float SSR_MARCH_QUALITY = 1.0;
// line rasterization

float2 GetUvFromPositionVs(float4 position_vs, float4x4 projection) {
    float4 position_cs = mul(projection, position_vs);
    position_cs /= position_cs.w;
    return (position_cs.xy * 0.5 + 0.5);
}

[numthreads(FULL_SCREEN_CS_THREAD_X, FULL_SCREEN_CS_THREAD_Y, FULL_SCREEN_CS_THREAD_Z)] 
void SSR_CS(uint3 id : SV_DispatchThreadID)
{
    float depth = depth_stencil_tex.Load(id).x;
    float2 uv = (float2(id.xy) + 0.5) / float2(width, height);
    float3 position_vs = ComputePositionVsFromDepth(uv, inverse_projection, depth).xyz;
    float3 normal_vs = mul(world_to_camera, normalize(normal_tex.Load(id).xyz));
    float3 v = normalize(-position_vs);

    float3 reflection_dir_vs = reflect(v, normal_vs);
    float3 origin_vs = position_vs;

    // reflection dir is always towards screen, end point can be clamp to near plane
    float ray_length =
    ((origin_vs.z + reflection_dir_vs.z * SSR_MAX_RAY_DISTANCE) > camera_near_plane)
    ? (camera_near_plane - origin_vs.z) / reflection_dir_vs.z
    : SSR_MAX_RAY_DISTANCE;
    float3 end_vs = reflection_dir_vs * ray_length + origin_vs;

    float2 p0 = GetUvFromPositionVs(origin_vs, projection);
    float2 p1 = GetUvFromPositionVs(end_vs, projection);

    float slope = (p1.y - p0.y) / (p1.x - p0.x);
    float sign = 
    // GPU DDA line rasterization
    for (int i = 0; i < SSR_MARCH_STEP; i++) {
        p += i * sign * SSR_MARCH_QUALITY * slope;
        p += reflection_dir_vs;
        // to uv space
        float4 p_cs = mul(projection, float4(p, 1.0));
        p_cs /= p_cs.w;

        if (p_cs.xy > 1.0 || p_cs.xy < -1.0) {
            return;
        }

        float uv = p_cs * 0.5 + 0.5;
        float sample_depth =
            depth_stencil_tex.SampleLevel(my_linear_clamp_sampler, uv, 0)
                .r;
            // march point is occluded by surface
            if (p_cs.z > sample_depth && (p_cs.z - sample_depth) < SSR_TRACE_THICKNESS) {
            ssr_color = color_tex.SampleLevel(my_linear_clamp_sampler, uv, 0);
            break;
            }
        }
    }

    ssr_tex[id.xy] = ssr_color;
}
