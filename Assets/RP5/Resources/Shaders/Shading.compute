// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma require WaveBallot

#include "UnityCG.cginc"
#include "HLSLSupport.cginc"
#include "brdf.hlsl"
#include "light.hlsl"
#include "material.hlsl"
#include "UnityLightingCommon.cginc"
#include "common.hlsl"
#include "debug.hlsl"
#include "common_math.hlsl"

Texture2D<float4> gdepth;
Texture2D<float4> gbuffer0; // world normal
Texture2D<float4> gbuffer1;
Texture2D<float4> gbuffer2;
Texture2D<float4> gbuffer3;
Texture2D<float4> gbuffer4;
RWTexture2D<float4> shading_rt;

uint directional_light_count;
uint point_light_count;
uint spot_light_count;
uint pad0;
float3 world_space_camera_pos;

StructuredBuffer<DirectionalLight> directional_lights;
StructuredBuffer<PointLight> point_lights;
StructuredBuffer<SpotLight> spot_lights;

float3 Lighting(float3 normal, float3 v, float3 light_dir, MaterialProperties mat) {
    // Calculate diffuse and specular components
    BXDF bxdf = InitBXDF(normal, v, light_dir);
    float D = NDF_GGX(mat.a2, bxdf.NoM);
    float G = Vis_SmithGGXCombined(mat.a2, bxdf.NoV, bxdf.NoL);
    float3 F = Fresnel_Schlick(mat.f0, bxdf.VoM);

    float3 diffuse = Diffuse_Lambert(mat.albedo) * (1 - mat.metallic); // TODO(hylu): layered material?
    float3 specular = D * G * F;
    return (diffuse + specular) * bxdf.NoL; 
}

[numthreads(FULL_SCREEN_CS_THREAD_X, FULL_SCREEN_CS_THREAD_Y, FULL_SCREEN_CS_THREAD_Z)] 
void CSMain(uint3 id : SV_DispatchThreadID) {

    float4 depth = gdepth.Load(id.xyz);

    // Check if the gbuffer pixel is invalid
    if(Equal(depth.w, 0.0) == 0.0) {
        shading_rt[id.xy] = float4(0.0,0.0,0.0,1.0);
        return;
    }

    float3 position_ws = gbuffer3.Load(id.xyz);
    // Load albedo, normal, and mr from gbuffer
    float3 albedo = gbuffer0.Load(id.xyz).rgb;
    float3 normal = gbuffer1.Load(id.xyz).rgb;
    float2 mr = gbuffer4.Load(id.xyz).rg;
    // Calculate view vector
    float3 v = normalize(world_space_camera_pos.xyz - position_ws);

    // Calculate roughness, metallic, and f0
    MaterialProperties mat = InitMaterial(albedo, normal, mr.x, mr.y);

    float3 radiance = float3(0.0, 0.0, 0.0);

    // Direct lighting
    for (uint i = 0; i < directional_light_count; i++) {
        float3 light_color = directional_lights[i].color;
        float light_intensity = directional_lights[i].intensity;
        float3 light_dir = normalize(-directional_lights[i].direction);
        // Check if the light is facing away from the surface
        if (dot(normal, light_dir) < 0.0) {
            continue;
        }

        float3 lighting =  Lighting(normal, v, light_dir, mat);

        // Calculate radiance
        radiance += lighting * light_color * light_intensity; // attenuation;
    }

    // Point lighting
    for (uint i = 0; i < point_light_count; i++) {
        float3 light_color = point_lights[i].color;
        float light_intensity = point_lights[i].intensity;
        
        float3 light_dir = point_lights[i].position - position_ws;

        // Check if the light is facing away from the surface
        if (dot(normal, light_dir) < 0.0) {
            continue;
        }

        float distance = length(light_dir);
        light_dir = normalize(light_dir);

        float3 lighting = Lighting(normal, v, light_dir, mat);
        float distance_attenuation = DistanceFalloff(distance, point_lights[i].falloff);

        // Calculate radiance
        radiance += lighting * light_color * light_intensity * distance_attenuation;
    }

    // Spot lighting
    for (uint i = 0; i < spot_light_count; i++) {
        float3 light_color = spot_lights[i].color;
        float light_intensity = spot_lights[i].intensity;
        
        float3 light_dir = -spot_lights[i].direction;

        // Check if the light is facing away from the surface
        if (dot(normal, light_dir) < 0.0) {
            continue;
        }

        float distance = length(spot_lights[i].position - position_ws);
        light_dir = normalize(light_dir);

        float3 lighting = Lighting(normal, v, light_dir, mat);
        float distance_attenuation = DistanceFalloff(distance, spot_lights[i].falloff);
        float angle_attenuation = AngleFalloff(spot_lights[i].inner_cone, spot_lights[i].outer_cone, spot_lights[i].direction, light_dir);

        // Calculate radiance
        radiance += lighting * light_color * light_intensity * distance_attenuation * angle_attenuation;
    }

    // Set the output color
    shading_rt[id.xy] = float4(radiance, 1.0);
}


