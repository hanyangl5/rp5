// Cluster Light Culling
#include "common.hlsl"
#include "light.hlsl"
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
 
//CBUFFER_START(SceneConstant)
	uint directional_light_count;
	uint point_light_count;
	uint spot_light_count;
    uint pad0;
//CBUFFER_END

// light lists
StructuredBuffer<PointLight> point_lights;
StructuredBuffer<SpotLight> spot_lights;

RWStructuredBuffer<uint> light_index_list;
RWStructuredBuffer<uint> light_count_list;
struct Frustum {
    float planes[6];
};

StructuredBuffer<Frustum> frusutm_planes;

Frustum GetFrustum(uint cell_index) {
    Frustum f;
    return f;
}
bool IntersectOBB(Frustum frustum, float3 center, float radius) {
    return true;
}

[numthreads(32, 32, 1)]
void CSMain (uint3 id : SV_DispatchThreadID, uint cell_index : SV_GroupIndex)
{
    Frustum frustum = GetFrustum(cell_index);
    
    uint active_light_count = 0;
    for (uint i = 0; i < point_light_count; i++) {
        if (IntersectOBB(frustum, point_lights[i].position, point_lights[i].falloff) == true) {
            light_index_list[cell_index * MAX_LIGHT_PER_CELL + active_light_count] |= i;
            active_light_count++;
        }
    }
    light_count_list[cell_index] |= active_light_count;

    active_light_count = 0;
    for (uint i = 0; i < spot_light_count; i++) {
        if (IntersectOBB(frustum, spot_lights[i].position, spot_lights[i].falloff) == true) {
            light_index_list[cell_index * MAX_LIGHT_PER_CELL + active_light_count] |= i << 16;
            active_light_count++;
        }
    }
    light_count_list[cell_index] |= active_light_count << 16;
}
