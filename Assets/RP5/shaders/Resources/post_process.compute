// defines
// 

#include "common.hlsl"

#define SINGLE_PASS_POST_PROCESS

float3 TonemapACES(float3 x)
{
	const float A = 2.51f;
	const float B = 0.03f;
	const float C = 2.43f;
	const float D = 0.59f;
	const float E = 0.14f;
	return (x * (A * x + B)) / (x * (C * x + D) + E);
}

float3 GammaCorrection(float3 x, float gamma) {
	return pow(x, (1.0f / gamma));
}

float3 ColorGrading(float3 x, Texture2D<float4> lut, SamplerState linear_sampler, uint lut_size) {
	float3 uvw = x * ((lut_size - 1) / lut_size) + (0.5f / lut_size);

	// a volume texture 16x16x16 would be unwrapped to a 2d texture 256x16

	half i_w = floor(uvw.z * (lut_size - 1) + 0.5f);

	float2 uv = float2((uvw.x + i_w) / lut_size, uvw.y);

	float3 grading_out = lut.Sample(linear_sampler, uv).rgb;

	return grading_out;
}

// float3 FilmGrain(float3 x, float scale) {
// 	float3 g = float3(grain(texCoord, p));
  
//     //blend the noise over the background, 
//     //i.e. overlay, soft light, additive
//     float3 color = blend(backgroundColor, g);
    
//     //get the luminance of the background
//     float luminance = luma(backgroundColor);
    
//     //reduce the noise based on some 
//     //threshold of the background luminance
//     float response = smoothstep(0.05, 0.5, luminance);
//     color = lerp(color, backgroundColor, pow(response, 2.0));
//     return color;
// }

#ifdef SINGLE_PASS_POST_PROCESS

#pragma kernel PostProcess_CS

RWTexture2D<float4> color_tex;

[numthreads(FULL_SCREEN_CS_THREAD_X, FULL_SCREEN_CS_THREAD_Y, FULL_SCREEN_CS_THREAD_Z)] 
void PostProcess_CS(uint3 id : SV_DispatchThreadID)
{
	float4 result = color_tex[id.xy];
	result.rgb = TonemapACES(result.rgb);
	result.rgb = GammaCorrection(result.rgb, 2.2f);
	color_tex[id.xy] = result; // float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}

#else

//// Each #kernel tells which function to compile; you can have many kernels
//#pragma kernel ToneMapping_CS

//// Create a RenderTexture with enableRandomWrite flag and set it
//// with cs.SetTexture
//RWTexture2D<float4> color_tex;



//[numthreads(8, 8, 1)] void ToneMapping_CS(uint3 id
//										  : SV_DispatchThreadID)
//{
//	color_tex[id.xy] = TonemapACES(color_tex[id.xy]); // float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
//}


#endif